# ğŸ› ï¸ BioFinder MCP â€” Developer Reference

This document covers the architecture, data model, MCP protocol surface, search
algorithm, and extension points for developers working on or integrating BioFinder.

## Architecture overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  User / LLM / Workflow                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  biofinder_client.py                        â”‚
â”‚  â€¢ CLI argument parsing                     â”‚
â”‚  â€¢ Interactive REPL                         â”‚
â”‚  â€¢ Formats & prints MCP responses           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚  JSON-RPC 2.0 over stdio
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  biofinder_server.py                        â”‚
â”‚  â€¢ BioFinderIndex (in-memory)               â”‚
â”‚    â”œâ”€â”€ metadata[]         â† YAML            â”‚
â”‚    â”œâ”€â”€ container_index{}  â† JSON.GZ         â”‚
â”‚    â””â”€â”€ search methods                       â”‚
â”‚  â€¢ MCP tool handlers                        â”‚
â”‚  â€¢ MCP resource handlers                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â–¼                         â–¼
  toolfinder_meta.yaml    galaxy_singularity_cache.json.gz
  714 tool records        118,594 container entries
```

The server and client communicate exclusively over **stdio** using the
[Model Context Protocol](https://modelcontextprotocol.io/) (JSON-RPC 2.0).
The server **must not print to stdout** outside of MCP messages â€” doing so breaks
the protocol framing.

---

## Data sources

### `toolfinder_meta.yaml`

Sourced from [AustralianBioCommons/finder-service-metadata](https://github.com/AustralianBioCommons/finder-service-metadata/blob/main/data/data.yaml).

Each record is a YAML object. Key fields used by BioFinder:

| Field | Type | Notes |
|---|---|---|
| `id` | string | Primary tool identifier, used as lookup key |
| `name` | string | Human-readable display name |
| `biotools` | string | bio.tools identifier (may differ from `id`) |
| `biocontainers` | string | BioContainers name (used for container lookup) |
| `description` | string \| null | Free-text description; used in `search_by_description` |
| `edam-operations` | list \| null | Controlled vocab for what the tool does |
| `edam-topics` | list \| null | Controlled vocab for scientific domain |
| `homepage` | string \| null | Project homepage URL |
| `license` | string \| null | SPDX identifier |

Many fields are `null` for a significant portion of tools â€” the search logic
guards against this throughout.

### `galaxy_singularity_cache.json.gz`

A gzipped JSON snapshot of the CVMFS Singularity image cache, generated by scanning
`/cvmfs/singularity.galaxyproject.org/all`. Top-level structure:

```json
{
  "generated_at": "2026-01-28T03:40:51.706534+00:00",
  "cvmfs_root": "/cvmfs/singularity.galaxyproject.org/all",
  "entry_count": 118594,
  "entries": [
    {
      "entry_name": "fastqc:0.12.1--hdfd78af_0",
      "tool_name": "fastqc",
      "tag": "0.12.1--hdfd78af_0",
      "path": "/cvmfs/singularity.galaxyproject.org/all/fastqc:0.12.1--hdfd78af_0",
      "size_bytes": 293400576,
      "mtime": 1697123456.0
    },
    ...
  ]
}
```

The `tool_name` field is the index key used to join with metadata. Tags follow
the Bioconda convention: `<version>--<build_string>`.

## MCP protocol surface

### Tools (4)

| Tool name | Description | Key argument(s) |
|---|---|---|
| `find_tool` | Exact/near-exact tool lookup | `tool_name: str` |
| `search_by_function` | Keyword search over metadata | `description: str`, `limit: int` |
| `get_container_versions` | Full version history for a tool | `tool_name: str` |
| `list_available_tools` | Alphabetical tool catalog | `limit: int` |

### Resources (2)

| URI | Description |
|---|---|
| `biocontainer://cache-info` | JSON: `generated_at`, `cvmfs_root`, `entry_count` |
| `biocontainer://tool-list` | Newline-separated list of all tool names |

---

## Search algorithm

### `find_tool` / `search_tool(query)`

1. **Exact metadata match** â€” compares `query` (lowercased) against `id`, `name`,
   `biotools`, and `biocontainers` fields.
2. **Partial metadata match** â€” if no exact match, checks whether `query` is a
   substring of `id` or vice-versa.
3. **Container lookup** â€” tries the query and two variations
   (`-` â†” `_` substitution) against `container_index`. Also tries the matched
   metadata record's `id` as a fallback key.
4. **Version sorting** â€” versions are sorted by parsing the leading
   `MAJOR.MINOR.PATCH` from the tag using a regex, then comparing as integer
   tuples, descending.

### `search_by_function` / `search_by_description(query, limit)`

Iterates all metadata records and computes a score:

| Signal | Score delta |
|---|---|
| Each query term found in description (word boundary) | +2 per term |
| Full query string is substring of description | +5 |
| Full query string is substring of an EDAM operation | +3 |
| Full query string is substring of an EDAM topic | +2 |
| Full query string is substring of tool name | +4 |
| Full query string is substring of tool ID | +4 |

Records with `score > 0` are returned, sorted descending, truncated to `limit`.

> âš ï¸ **Known issue:** the scoring is a rough heuristic. Short stop-words in the
> query inflate scores for unrelated tools, and EDAM coverage is uneven. See
> [Future improvements](#future-improvements).

---

## Project layout

TODO: Update

```
.
â”œâ”€â”€ biofinder_server.py          # MCP server + BioFinderIndex
â”œâ”€â”€ biofinder_client.py          # CLI client
â”œâ”€â”€ test_demo.py                 # Standalone smoke test (no MCP dependency)
â”œâ”€â”€ toolfinder_meta.yaml         # Tool metadata (data source)
â”œâ”€â”€ galaxy_singularity_cache.json.gz  # Container cache (data source)
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ setup.sh
â””â”€â”€ docs/
    â”œâ”€â”€ QUICKSTART.md            # User: get started in 2 minutes
    â”œâ”€â”€ HOW_TO_QUERY.md          # User: all query types with examples
    â”œâ”€â”€ DEVELOPER_REFERENCE.md   # Dev: this document
    â””â”€â”€ REFERENCE.md             # Reference: CLI flags, MCP schema
```

## Running locally

```bash
# Install deps
pip install mcp pyyaml

# Smoke test (no MCP, reads data files directly)
python3 test_demo.py

# One-shot client query (starts and stops the server automatically)
./biofinder_client.py find fastqc

# Interactive session
./biofinder_client.py interactive
```

The client spawns `biofinder_server.py` as a subprocess and communicates over its
stdin/stdout. The server loads both data files into memory on startup (~2 s on
first run) and holds them for the lifetime of the process.

## Updating data files

The index is rebuilt from scratch on every server startup, so updating either data
file takes effect immediately on the next run.

**Metadata** â€” replace `toolfinder_meta.yaml` with a newer version from the
[finder-service-metadata repo](https://github.com/AustralianBioCommons/finder-service-metadata).

**Container cache** â€” the cache file is generated by scanning the live CVMFS mount.
Documentation for regenerating it is tracked in [#TODO].

## Future improvements

The following are known gaps to address:

- **Incomplete metadata.** The `search` functionality uses available metadata
  to return relevant containers. It is limited by incomplete,
  or inconsistent metadata from bio.tools, and may also lack entries for uncommon
  tools. Consider pulling in additional metadata from BioContainers. Previous
  iterations biased tools that had complete metadata, over tools with none.

- **Semantic search.** The keyword scorer produces noisy results for vague queries.
  Embedding descriptions with a small sentence-transformer and doing ANN lookup
  would give significantly better recall and precision. Consider
  vector embeddings and retrieval.

- **Score calibration.** The current integer weights have not been benchmarked
  against real queries. A small evaluation set of (query, expected_tools) pairs
  would enable tuning, and is a prerequisite for any LLM-assisted reranking.

- **LLM-assisted reranking.** A lightweight prompt that takes the top-N scored
  results and reranks them given the original natural-language query would
  dramatically improve usability without requiring embeddings infrastructure.

- **Using the correct LLM.** Consider using a local model for LLM-enriched answers to
  avoid charges on usage. The local model needs to be suited to the data (e.g.
  [bioBERT](https://huggingface.co/dmis-lab/biobert-base-cased-v1.2)) etc.

- **Stop-word filtering.** The `search_by_description` scorer inflates scores for
  common words (`data`, `the`, `for`). A simple stop-word list would sharpen results.

- **Container cache regeneration docs.** The process for producing
  `galaxy_singularity_cache.json.gz` from a live CVMFS mount is not yet
  documented.

- **Stale container warnings.** The cache has a `generated_at` timestamp. The
  server could warn users when the cache is older than a configurable threshold.
  Explore how CVMFS can utilise caching.

- **Support for natural language queries.** Currently the MCP works best for succinct
  and precise queries. e.g. `biofinder> search variant calling` yields more useful
  results in comparison to `biofinder> search "Find where mutations are"`.

